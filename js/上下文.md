# 作用域
- 作用域是程序源代码中定义变量的区域
- 作用域规定了如何查找变量，也就是确定了当前执行代码对变量的访问权限
- JavaScript采用词法作用域，也就是静态作用域，函数的作用域在函数定义（创建）的时候就定义了
# 上下文
## 前言：
- JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”
- 这里说的可执行代码指的是全局代码，函数代码，eval代码
- 当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(execution context)"。
- JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。每个上下文都有三个重要属性：变量对象(Variable object，VO)，作用域链(Scope chain)，this
## 执行上下文栈
- JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文
- 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出
## 变量对象
### 概念
- 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明
- 对于全局上下文来说,变量对象就是全局对象
- 在函数上下文中，活动对象（AO）就是变量对象(VO)

### 变量对象的创建（根据上下文分两阶段完成）
1. 进入执行上下文
    当进入执行上下文时，这时候还没有执行代码,变量对象会包括:

  - 函数的所有形参

    没有实参的话，属性值设为undefined

  - 函数声明

    如果变量对象已经存在相同名称的属性，则完全替换这个属性

  - 变量声明

    如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
2. 执行代码
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
## 作用域链

- 函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中

- 当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端

- 这时候执行上下文的作用域链，我们命名为 Scope：

  ```
  Scope = [AO].concat([[Scope]]);
  ```
- 每个函数维护一条作用域链，内部包含了所有父变量对象，全局的变量对象始终都是作用域链中的最后一个对象

  ```
  [AO,son.VO,father.VO]
  ```


###  函数scope属性

- scope属性里并不是包含父变量对象的所有属性，只会包含在函数中使用到的自由变量





# 闭包
## 概述
- MDN解释闭包：函数和其周围环境（词法环境）的引用捆绑在一起构成闭包（也就是那些能够访问自由变量的函数）

- ECMAscript解释闭包：

  + 理论角度：所有函数都是闭包

  + 实践角度，满足以下条件才是闭包

    1. 创建它的上下文已经销毁，但是它仍然存在

    2. 在代码中引入了自由变量

- 也有说函数+[[scope]]构成闭包

- 自由变量：是指在函数中使用的，但既不是函数参数，也不是函数的局部变量的变量